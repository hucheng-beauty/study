package factory_mode

/*
	工厂模式(如果创建对象是一个简单的 new 就能完成的,简单工厂更好一些;如果创建对象比较复杂,采用工厂方法)
		简单工厂（Simple Factory）
			使用场景：
			  a. 当每个对象的创建逻辑都比较简单的时候，将多个对象的创建逻辑放到一个工厂类中。
			实现：
			  a. if else 创建不同的对象。
			  b. 用单例模式 + 简单工厂模式结合来实现。
		工厂方法（Factory Method）
			使用场景：
			  a. 当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类时，
				 将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。
			  b. 避免很多 if-else 分支逻辑时。
			实现：
			  a. 定义相应的ParserFactory接口，每个工厂定义一个实现类。这种方式使用会有多个if else 让使用更加复杂。
			  b. 创建工厂的工厂来，此方案可以解决上面的问题。
		抽象工厂（Abstract Factory）- 不常用
			使用场景：
			  a. 有多种分类方式，如方式要用一套工厂方法，方式二要用一套工厂方法，详见原文例子。
			实现：
			  让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。

	工厂模式的最本质的参考标准
		封装变化：创建逻辑有可能变化，封装成工厂类之后,创建逻辑的变更对调用者透明
		代码复用：创建代码抽离到独立的工厂类之后可以复用
		隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
		控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁

	工厂方法和抽象工厂
		相同点
			都是先定义工厂接口,由子类去创建实际的对象
		不同点
			每个工厂方法只负责创建一种对象,解决的是一维问题
			抽象工厂一个工厂创建一簇对象（多种）,解决的是多维问题
		联系
			工厂方法是抽象工厂的一种特例;抽象工厂是采用降维的思想来解决复杂问题

*/

// Cache 抽象的产品
type Cache interface {
	Set(key, value string)
	Get(key string) string
}

// CacheFactory 抽象产品的工厂
type CacheFactory interface {
	Create() (Cache, error)
}
